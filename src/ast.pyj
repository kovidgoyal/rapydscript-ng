# vim:fileencoding=utf-8
# License: BSD

from utils import noop, string_template

def DEFNODE(type, props, methods, base):
    if arguments.length < 4:
        base = AST_Node

    if not props:
        props = []
    else:
        props = props.split(/\s+/)

    self_props = props
    if base and base.PROPS:
        props = props.concat(base.PROPS)

    code = "return function AST_" + type + "(props){ if (props) { "
    for i in range(props.length-1, -1, -1):
        code += "this." + props[i] + " = props." + props[i] + ";"

    proto = base and new base()
    if proto and proto.initialize or methods and methods.initialize:
        code += "this.initialize();"

    code += "}}"
    ctor = new Function(code)()
    if proto:
        ctor.prototype = proto
        ctor.BASE = base

    if base:
        base.SUBCLASSES.push(ctor)

    ctor.prototype.CTOR = ctor
    ctor.PROPS = props or None
    ctor.SELF_PROPS = self_props
    ctor.SUBCLASSES = []
    if type:
        ctor.prototype.TYPE = ctor.TYPE = type

    if methods:
        for i in methods:
            if /^\$/.test(i):
                ctor[i.substr(1)] = methods[i]
            else:
                ctor.prototype[i] = methods[i]

    ctor.DEFMETHOD = def(name, method):
        this.prototype[name] = method

    return ctor

AST_Token = DEFNODE("Token", "type value line col pos endpos nlb comments_before file", {}, None)

AST_Node = DEFNODE("Node", "start end", {
    'clone': def():
        return new this.CTOR(this)
    ,
    '$documentation': "Base class of all AST nodes",
    '$propdoc': {
        'start': "[AST_Token] The first token of this node",
        'end': "[AST_Token] The last token of this node"
    },
    '_walk': def(visitor):
        return visitor._visit(this)
    ,
    'walk': def(visitor):
        return this._walk(visitor)
    ,
    '_dump': def(depth=100, omit={'start', 'end'}, offset=0, include_name=True):
        p = console.log
        reset = "\x1b[0m"
        yellow = "\x1b[33m"
        blue = "\x1b[34m"
        green = "\x1b[32m"
        red = "\x1b[31m"
        magenta = "\x1b[35m"
        pad = Array(offset + 1).join('  ')

        if include_name:
            p(pad + yellow + this.TYPE + reset)
        for key in this:
            if key in omit:
                continue

            if Array.isArray(this[key]):
                if this[key].length:
                    p(pad + ' ' + blue + key + ': ' + reset + '[')
                    if depth > 1:
                        for element in this[key]:
                            element._dump(depth-1, omit, offset+1, True)
                    else:
                        for element in this[key]:
                            p(pad + '   ' + yellow + element.TYPE + reset)
                    p(pad + ' ]')
                else:
                    p(pad + ' ' + blue + key + ': ' + reset + '[]')
            elif this[key]:
                if this[key].TYPE:
                    if this[key].TYPE is 'Token':
                        p(pad + ' ' + blue + key + ': ' + magenta + this[key].TYPE + reset)
                        for property in this[key]:
                            p(pad + '   ' + blue + property + ': ' + reset + this[key][property])
                    else:
                        p(pad + ' ' + blue + key + ': ' + yellow + this[key].TYPE + reset)
                        if depth > 1:
                            this[key]._dump(depth-1, omit, offset+1, False)
                elif type(this[key]) is "string":
                    p(pad + ' ' + blue + key + ': ' + green + '"' + this[key] + '"' + reset)
                elif type(this[key]) is "number":
                    p(pad + ' ' + blue + key + ': ' + green + this[key] + reset)
                else:
                    # unexpected object
                    p(pad + ' ' + blue + key + ': ' + red + this[key] + reset)
            else:
                # none/undefined
                p(pad + ' ' + blue + key + ': ' + reset + this[key])

    ,
    # a more user-friendly way to dump the AST tree than console.log
    'dump': def(depth=2, omit=[]):
        return this._dump(depth, omit, 0, True)
}, None)
AST_Node.warn_function = None
AST_Node.warn = def(txt, props):
    if AST_Node.warn_function:
        AST_Node.warn_function(string_template(txt, props))

# -----[ statements ]-----
AST_Statement = DEFNODE("Statement", None, {
    '$documentation': "Base class of all statements"
})

AST_Debugger = DEFNODE("Debugger", None, {
    '$documentation': "Represents a debugger statement"
}, AST_Statement)

AST_Directive = DEFNODE("Directive", "value scope", {
    '$documentation': 'Represents a directive, like "use strict";',
    '$propdoc': {
        'value': "[string] The value of this directive as a plain string (it's not an AST_String!)",
        'scope': "[AST_Scope/S] The scope that this directive affects"
    }
}, AST_Statement)

AST_SimpleStatement = DEFNODE("SimpleStatement", "body", {
    '$documentation': "A statement consisting of an expression, i.e. a = 1 + 2",
    '$propdoc': {
        'body': "[AST_Node] an expression node (should not be instanceof AST_Statement)"
    },
    '_walk': def(visitor):
        node = this
        return visitor._visit(node, def():
            node.body._walk(visitor)
        )

}, AST_Statement)

def walk_body(node, visitor):
    if isinstance(node.body, AST_Statement):
        node.body._walk(visitor)
    elif node.body:
        node.body.forEach(def(stat):
            stat._walk(visitor)
        )

AST_Block = DEFNODE("Block", "body", {
    '$documentation': "A body of statements (usually bracketed)",
    '$propdoc': {
        'body': "[AST_Statement*] an array of statements"
    },
    '_walk': def(visitor):
        node = this
        return visitor._visit(this, def():
            walk_body(node, visitor)
        )
}, AST_Statement)

AST_BlockStatement = DEFNODE("BlockStatement", None, {
    '$documentation': "A block statement"
}, AST_Block)

AST_EmptyStatement = DEFNODE("EmptyStatement", 'stype', {
    '$documentation': "The empty statement (empty block or simply a semicolon)",
    '$propdoc': {
        'stype': "[string] the type of empty statement. Is ; for semicolons",
    },
    '_walk': def(visitor):
        return visitor._visit(this)
}, AST_Statement)

AST_StatementWithBody = DEFNODE("StatementWithBody", "body", {
    '$documentation': "Base class for all statements that contain one nested body: `For`, `ForIn`, `Do`, `While`, `With`",
    '$propdoc': {
        'body': "[AST_Statement] the body; this should always be present, even if it's an AST_EmptyStatement"
    },
    '_walk': def(visitor):
        node = this
        return visitor._visit(node, def():
            node.body._walk(visitor)
        )
}, AST_Statement)

AST_DWLoop = DEFNODE("DWLoop", "condition", {
    '$documentation': "Base class for do/while statements",
    '$propdoc': {
        'condition': "[AST_Node] the loop condition.  Should not be instanceof AST_Statement"
    },
    '_walk': def(visitor):
        node = this
        return visitor._visit(node, def():
            node.condition._walk(visitor)
            node.body._walk(visitor)
        )
}, AST_StatementWithBody)

AST_Do = DEFNODE("Do", None, {
    '$documentation': "A `do` statement"
}, AST_DWLoop)

AST_While = DEFNODE("While", None, {
    '$documentation': "A `while` statement"
}, AST_DWLoop)

AST_ForIn = DEFNODE("ForIn", "init name object", {
    '$documentation': "A `for ... in` statement",
    '$propdoc': {
        'init': "[AST_Node] the `for/in` initialization code",
        'name': "[AST_SymbolRef?] the loop variable, only if `init` is AST_Var",
        'object': "[AST_Node] the object that we're looping through"
    },
    '_walk': def(visitor):
        node = this
        return visitor._visit(node, def():
            node.init._walk(visitor)
            if (node.name) node.name._walk(visitor)
            node.object._walk(visitor)
            if node.body:
                node.body._walk(visitor)
        )
}, AST_StatementWithBody)

AST_ForJS = DEFNODE("ForJS", "condition", {
    '$documentation': "A `for ... in` statement",
    '$propdoc': {
        'condition': "[AST_Verbatim] raw JavaScript conditional"
    },
}, AST_StatementWithBody)

AST_ListComprehension = DEFNODE("ListComprehension", "condition statement", {
    '$documentation': "A list comprehension expression",
    '$propdoc': {
        'condition': "[AST_Node] the `if` condition",
        'statement': "[AST_Node] statement to perform on each element before returning it"
    },
    '_walk': def(visitor):
        node = this
        return visitor._visit(node, def():
            node.init._walk(visitor)
            node.object._walk(visitor)
            node.statement._walk(visitor)
            if (node.condition) node.condition._walk(visitor)
        )
    ,
}, AST_ForIn)

AST_SetComprehension = DEFNODE('SetComprehension', None, {
    '$documentation': 'A set comprehension',
}, AST_ListComprehension)

AST_DictComprehension = DEFNODE('DictComprehension', 'value_statement is_pydict', {
    '$documentation': 'A set comprehension',
    '$propdoc': {
        'value_statement': "[AST_Node] statement to perform on each value before returning it",
        'is_pydict': "[bool] True if this comprehension is for a python dict",
    },
    '_walk': def(visitor):
        node = this
        return visitor._visit(node, def():
            node.init._walk(visitor)
            node.object._walk(visitor)
            node.statement._walk(visitor)
            node.value_statement._walk(visitor)
            if (node.condition) node.condition._walk(visitor)
        )
    ,
}, AST_ListComprehension)

AST_GeneratorComprehension = DEFNODE('GeneratorComprehension', None, {
    '$documentation': 'A generator comprehension',
}, AST_ListComprehension)

AST_With = DEFNODE("With", "clauses", {
    '$documentation': "A `with` statement",
    '$propdoc': {
        'clauses': "[AST_WithClause*] the `with` clauses (comma separated)"
    },
    '_walk': def(visitor):
        node = this
        return visitor._visit(node, def():
            node.clauses.forEach(def(exp):
                exp._walk(visitor)
            )
            node.body._walk(visitor)
        )
}, AST_StatementWithBody)

AST_WithClause = DEFNODE('WithClause', 'expression alias', {
    '$documentation': 'A clause in a with statement',
    '$propdoc': {
        'expression': '[AST_Node] the expression',
        'alias': '[AST_SymbolAlias?] optional alias for this expression',
    },
    '_walk': def(visitor):
        node = this
        return visitor._visit(node, def():
            node.expression._walk(visitor)
            if node.alias:
                node.alias._walk(visitor)
        )
}, AST_Node)

# -----[ scope and functions ]-----
AST_Scope = DEFNODE("Scope", "directives variables localvars functions uses_with uses_eval parent_scope enclosed cname", {
    '$documentation': "Base class for all statements introducing a lexical scope",
    '$propdoc': {
        'directives': "[string*/S] an array of directives declared in this scope",
        'variables': "[Object/S] a map of name -> SymbolDef for all variables/functions defined in this scope",
        'localvars': "[SymbolDef*] list of variables local to this scope",
        'functions': "[Object/S] like `variables`, but only lists function declarations",
        'uses_with': "[boolean/S] tells whether this scope uses the `with` statement",
        'uses_eval': "[boolean/S] tells whether this scope contains a direct call to the global `eval`",
        'parent_scope': "[AST_Scope?/S] link to the parent scope",
        'enclosed': "[SymbolDef*/S] a list of all symbol definitions that are accessed from this scope or any subscopes",
        'cname': "[integer/S] current index for mangling variables (used internally by the mangler)"
    }
}, AST_Block)

AST_Toplevel = DEFNODE("Toplevel", "globals baselib imports imported_module_ids shebang import_order module_id exports submodules classes filename srchash", {
    '$documentation': "The toplevel scope",
    '$propdoc': {
        'globals': "[Object/S] a map of name -> SymbolDef for all undeclared names",
        'baselib': "[Object/s] a collection of used parts of baselib",
        'imports': "[Object/S] a map of module_id->AST_Toplevel for all imported modules (this represents all imported modules across all source files)",
        'imported_module_ids': "[string*] a list of module ids that were imported by this module, specifically",
        'nonlocalvars': "[String*] a list of all non-local variable names (names that come from the global scope)",
        'shebang': "[string] If #! line is present, it will be stored here",
        'import_order': "[number] The global order in which this scope was imported",
        'module_id': "[string] The id of this module",
        'exports': "[SymbolDef*] list of names exported from this module",
        'submodules': "[string*] list of names exported from this module",
        'classes': "[Object/S] a map of class names to AST_Class for classes defined in this module",
        'filename': "[string] The absolute path to the file from which this module was read",
        'srchash': "[string] SHA1 hash of source code, used for caching",
    },
}, AST_Scope)

AST_Import = DEFNODE("Import", "module key alias argnames body", {
    '$documentation': "Container for a single import",
    '$propdoc': {
        'module': "[AST_SymbolVar] name of the module we're importing",
        'key':  "[string] The key by which this module is stored in the global modules mapping",
        'alias': "[AST_SymbolAlias] The name this module is imported as, can be None. For import x as y statements.",
        'argnames': "[AST_ImportedVar*] names of objects to be imported",
        'body': "[AST_TopLevel] parsed contents of the imported file",
    },
    '_walk': def(visitor):
        node = this
        return visitor._visit(node, def():
            if node.alias:
                node.alias._walk(visitor)
            if node.argnames:
                node.argnames.forEach(def(arg):
                    arg._walk(visitor)
                )
        )
    ,

}, AST_Statement)

AST_Imports = DEFNODE('Imports', 'imports', {
    '$documentation': "Container for a single import",
    '$propdoc': {
        'imports': "[AST_Import+] array of imports",
    },
    '_walk': def(visitor):
        node = this
        return visitor._visit(node, def():
            node.imports.forEach(def(imp):
                imp._walk(visitor)
            )
        )
    ,

}, AST_Statement)

AST_Decorator = DEFNODE("Decorator", "expression", {
    '$documentation': "Class for function decorators",
    '$propdoc': {
        'expression': "[AST_Node] the decorator expression"
    },
    '_walk': def(visitor):
        node = this
        return visitor._visit(node, def():
            if node.expression:
                node.expression.walk(visitor)
        )
    ,
})

AST_Lambda = DEFNODE("Lambda", "name argnames decorators is_generator is_expression", {
    '$documentation': "Base class for functions",
    '$propdoc': {
        'name': "[AST_SymbolDeclaration?] the name of this function",
        'argnames': "[AST_SymbolFunarg*] array of function arguments",
        'decorators': "[AST_Decorator*] function decorators, if any",
        'is_generator': "[bool*] True iff this function is a generator",
        'is_expression': "[bool*] True iff this function is a function expression",
    },
    '_walk': def(visitor):
        node = this
        return visitor._visit(node, def():
            if node.decorators:
                for d in node.decorators:
                    d.walk(visitor)
            if node.name:
                node.name._walk(visitor)

            node.argnames.forEach(def(arg):
                arg._walk(visitor)
            )
            if node.argnames.starargs:
                node.argnames.starargs._walk(visitor)
            if node.argnames.kwargs:
                node.argnames.kwargs._walk(visitor)
            walk_body(node, visitor)
        )
}, AST_Scope)

AST_Function = DEFNODE("Function", None, {
    '$documentation': "A function expression"
}, AST_Lambda)

AST_Class = DEFNODE("Class", "init name parent static external bound decorators module_id statements dynamic_properties", {
    '$documentation': "A class declaration",
    '$propdoc': {
        'name': "[AST_SymbolDeclaration?] the name of this class",
        'init': "[AST_Function] constructor for the class",
        'parent': "[AST_Symbol?] parent class this class inherits from",
        "static": "[string*] list of static methods",
        'external': "[boolean] true if class is declared elsewhere, but will be within current scope at runtime",
        'bound': "[string*] list of methods that need to be bound to behave correctly (function pointers)",
        'decorators': "[AST_Decorator*] function decorators, if any",
        'module_id': "[string] The id of the module this class is defined in",
        'statements': "[AST_Node*] list of statements in the class scope (excluding method definitions)",
        'dynamic_properties': '[dict] map of dynamic property names to property descriptors of the form {getter:AST_Method, setter:AST_Method',
    },
    '_walk': def(visitor):
        node = this
        return visitor._visit(node, def():
            if node.decorators:
                for d in node.decorators:
                    d.walk(visitor)
            node.name._walk(visitor)
            walk_body(node, visitor)
            if (node.parent) node.parent._walk(visitor)
        )
}, AST_Scope)

AST_Method = DEFNODE("Method", "static is_getter is_setter", {
    '$documentation': "A class method definition",
    '$propdoc': {
        "static": "[boolean] true if method is static",
        "is_getter": "[boolean] true if method is a property getter",
        "is_setter": "[boolean] true if method is a property setter",
    }
}, AST_Lambda)

# -----[ JUMPS ]-----
AST_Jump = DEFNODE("Jump", None, {
    '$documentation': "Base class for “jumps” (for now that's `return`, `throw`, `break` and `continue`)"
}, AST_Statement)

AST_Exit = DEFNODE("Exit", "value", {
    '$documentation': "Base class for “exits” (`return` and `throw`)",
    '$propdoc': {
        'value': "[AST_Node?] the value returned or thrown by this statement; could be null for AST_Return"
    },
    '_walk': def(visitor):
        node = this
        return visitor._visit(node, def():
            if node.value:
                node.value._walk(visitor)
        )
}, AST_Jump)

AST_Return = DEFNODE("Return", None, {
    '$documentation': "A `return` statement"
}, AST_Exit)

AST_Yield = DEFNODE("Yield", "is_yield_from", {
    '$documentation': "A `yield` statement",
    '$propdoc': {
        'is_yield_from': "[bool] True iff this is a yield from, False otherwise"
    },
}, AST_Return)

AST_Throw = DEFNODE("Throw", None, {
    '$documentation': "A `throw` statement"
}, AST_Exit)

AST_LoopControl = DEFNODE("LoopControl", None, {
    '$documentation': "Base class for loop control statements (`break` and `continue`)",
}, AST_Jump)

AST_Break = DEFNODE("Break", None, {
    '$documentation': "A `break` statement"
}, AST_LoopControl)

AST_Continue = DEFNODE("Continue", None, {
    '$documentation': "A `continue` statement"
}, AST_LoopControl)

# -----[ IF ]-----
AST_If = DEFNODE("If", "condition alternative", {
    '$documentation': "A `if` statement",
    '$propdoc': {
        'condition': "[AST_Node] the `if` condition",
        'alternative': "[AST_Statement?] the `else` part, or null if not present"
    },
    '_walk': def(visitor):
        node = this
        return visitor._visit(node, def():
            node.condition._walk(visitor)
            node.body._walk(visitor)
            if node.alternative:
                node.alternative._walk(visitor)
        )
}, AST_StatementWithBody)

# -----[ EXCEPTIONS ]-----
AST_Try = DEFNODE("Try", "bcatch bfinally", {
    '$documentation': "A `try` statement",
    '$propdoc': {
        'bcatch': "[AST_Catch?] the catch block, or null if not present",
        'bfinally': "[AST_Finally?] the finally block, or null if not present"
    },
    '_walk': def(visitor):
        node = this
        return visitor._visit(node, def():
            walk_body(node, visitor)
            if node.bcatch:
                node.bcatch._walk(visitor)

            if node.bfinally:
                node.bfinally._walk(visitor)
        )
}, AST_Block)

# XXX: this is wrong according to ECMA-262 (12.4).  the catch block
# should introduce another scope, as the argname should be visible
# only inside the catch block.  However, doing it this way because of
# IE which simply introduces the name in the surrounding scope.  If
# we ever want to fix this then AST_Catch should inherit from
# AST_Scope.
AST_Catch = DEFNODE("Catch", None, {
    '$documentation': "A `catch` node; only makes sense as part of a `try` statement",
    '$propdoc': {},
}, AST_Block)

AST_Except = DEFNODE("Except", "argname errors", {
    '$documentation': "An `except` node for RapydScript, which resides inside the catch block",
    '$propdoc': {
        'argname': "[AST_SymbolCatch] symbol for the exception",
        'errors': "[AST_SymbolVar*] error classes to catch in this block"
    },
    '_walk': def(visitor):
        node = this
        return visitor._visit(this, def():
            if (node.argname):
                node.argname.walk(visitor)
            if (node.errors):
                for e in node.errors: e.walk(visitor)
            walk_body(node, visitor)
        )
}, AST_Block)

AST_Finally = DEFNODE("Finally", None, {
    '$documentation': "A `finally` node; only makes sense as part of a `try` statement"
}, AST_Block)

# -----[ VAR/CONST ]-----
AST_Definitions = DEFNODE("Definitions", "definitions", {
    '$documentation': "Base class for `var` or `const` nodes (variable declarations/initializations)",
    '$propdoc': {
        'definitions': "[AST_VarDef*] array of variable definitions"
    },
    '_walk': def(visitor):
        node = this
        return visitor._visit(node, def():
            node.definitions.forEach(def(def_):
                def_._walk(visitor)
            )
        )
}, AST_Statement)

AST_Var = DEFNODE("Var", None, {
    '$documentation': "A `var` statement"
}, AST_Definitions)

AST_Const = DEFNODE("Const", None, {
    '$documentation': "A `const` statement"
}, AST_Definitions)

AST_VarDef = DEFNODE("VarDef", "name value", {
    '$documentation': "A variable declaration; only appears in a AST_Definitions node",
    '$propdoc': {
        'name': "[AST_SymbolVar|AST_SymbolConst|AST_SymbolNonlocal] name of the variable",
        'value': "[AST_Node?] initializer, or null if there's no initializer"
    },
    '_walk': def(visitor):
        node = this
        return visitor._visit(node, def():
            node.name._walk(visitor)
            if node.value:
                node.value._walk(visitor)
        )
})

# -----[ OTHER ]-----
AST_BaseCall = DEFNODE("BaseCall", "args", {
    '$documentation': "A base class for function calls",
    '$propdoc': {
        'args': "[AST_Node*] array of arguments"
    }
})

AST_Call = DEFNODE("Call", "expression", {
    '$documentation': "A function call expression",
    '$propdoc': {
        'expression': "[AST_Node] expression to invoke as function"
    },
    '_walk': def(visitor):
        node = this
        return visitor._visit(node, def():
            node.expression._walk(visitor)
            node.args.forEach(def(arg):
                arg._walk(visitor)
            )
            if (node.args.kwargs) node.args.kwargs.forEach(def(arg):
                arg[0]._walk(visitor)
                arg[1]._walk(visitor)
            )
            if (node.args.kwarg_items) node.args.kwarg_items.forEach(def(arg):
                arg._walk(visitor)
            )
        )

}, AST_BaseCall)

AST_ClassCall = DEFNODE("ClassCall", "class method static", {
    '$documentation': "A function call expression",
    '$propdoc': {
        "class": "[string] name of the class method belongs to",
        'method': "[string] class method being called",
        "static": "[boolean] defines whether the method is static"
    },
    '_walk': def(visitor):
        node = this
        return visitor._visit(node, def():
            if (node.expression) node.expression._walk(visitor)
            node.args.forEach(def(arg):
                arg._walk(visitor)
            )
            node.args.kwargs.forEach(def(arg):
                arg[0]._walk(visitor)
                arg[1]._walk(visitor)
            )
            node.args.kwarg_items.forEach(def(arg):
                arg._walk(visitor)
            )
        )

}, AST_BaseCall)

AST_New = DEFNODE("New", None, {
    '$documentation': "An object instantiation. Derives from a function call since it has exactly the same properties"
}, AST_Call)

AST_Seq = DEFNODE("Seq", "car cdr", {
    '$documentation': "A sequence expression (two comma-separated expressions)",
    '$propdoc': {
        'car': "[AST_Node] first element in sequence",
        'cdr': "[AST_Node] second element in sequence"
    },
    '$cons': def(x, y):
        seq = new AST_Seq(x)
        seq.car = x
        seq.cdr = y
        return seq
    ,
    '$from_array': def(array):
        if array.length is 0:
            return None

        if array.length is 1:
            return array[0].clone()

        list = None
        for i in range(array.length-1, -1, -1):
            list = AST_Seq.cons(array[i], list)

        p = list
        while p:
            if p.cdr and not p.cdr.cdr:
                p.cdr = p.cdr.car
                break
            p = p.cdr
        return list
    ,
    'to_array': def():
        p = this
        a = []
        while p:
            a.push(p.car)
            if p.cdr and not (isinstance(p.cdr, AST_Seq)):
                a.push(p.cdr)
                break
            p = p.cdr
        return a
    ,
    'add': def(node):
        p = this
        while p:
            if not (isinstance(p.cdr, AST_Seq)):
                cell = AST_Seq.cons(p.cdr, node)
                return p.cdr = cell
            p = p.cdr
    ,
    '_walk': def(visitor):
        node = this
        return visitor._visit(node, def():
            node.car._walk(visitor)
            if node.cdr:
                node.cdr._walk(visitor)
        )
})

AST_PropAccess = DEFNODE("PropAccess", "expression property", {
    '$documentation': 'Base class for property access expressions, i.e. `a.foo` or `a["foo"]`',
    '$propdoc': {
        'expression': "[AST_Node] the “container” expression",
        'property': "[AST_Node|string] the property to access.  For AST_Dot this is always a plain string, while for AST_Sub it's an arbitrary AST_Node"
    }
})

AST_Dot = DEFNODE("Dot", None, {
    '$documentation': "A dotted property access expression",
    '_walk': def(visitor):
        node = this
        return visitor._visit(node, def():
            node.expression._walk(visitor)
        )
}, AST_PropAccess)

AST_Sub = DEFNODE("Sub", None, {
    '$documentation': 'Index-style property access, i.e. `a["foo"]`',
    '_walk': def(visitor):
        node = this
        return visitor._visit(node, def():
            node.expression._walk(visitor)
            node.property._walk(visitor)
        )
}, AST_PropAccess)

AST_ItemAccess = DEFNODE("ItemAccess", "assignment", {
    '$documentation': 'Python index-style property access, i.e. `a.__getitem__("foo")`',
    '$propdoc': {
        'assignment': "[AST_Node or None] Not None if this is an assignment (a[x] = y) rather than a simple access",
    },
    '_walk': def(visitor):
        node = this
        return visitor._visit(node, def():
            node.expression._walk(visitor)
            node.property._walk(visitor)
            if node.assignment:
                node.assignment._walk(visitor)
        )
}, AST_PropAccess)

AST_Splice = DEFNODE("Slice", "property2 assignment", {
    '$documentation': 'Index-style property access, i.e. `a[3:5]`',
    '$propdoc': {
        'property2': "[AST_Node] the 2nd property to access - typically ending index for the array.",
        'assignment': "[AST_Node] The data being spliced in."
    },
    '_walk': def(visitor):
        node = this
        return visitor._visit(node, def():
            node.expression._walk(visitor)
            node.property._walk(visitor)
            node.property2._walk(visitor)
        )
}, AST_PropAccess)

AST_Unary = DEFNODE("Unary", "operator expression", {
    '$documentation': "Base class for unary expressions",
    '$propdoc': {
        'operator': "[string] the operator",
        'expression': "[AST_Node] expression that this unary operator applies to"
    },
    '_walk': def(visitor):
        node = this
        return visitor._visit(node, def():
            node.expression._walk(visitor)
        )
})

AST_UnaryPrefix = DEFNODE("UnaryPrefix", None, {
    '$documentation': "Unary prefix expression, i.e. `typeof i` or `++i`"
}, AST_Unary)

AST_UnaryPostfix = DEFNODE("UnaryPostfix", None, {
    '$documentation': "Unary postfix expression, i.e. `i++`"
}, AST_Unary)

AST_Binary = DEFNODE("Binary", "left operator right", {
    '$documentation': "Binary expression, i.e. `a + b`",
    '$propdoc': {
        'left': "[AST_Node] left-hand side expression",
        'operator': "[string] the operator",
        'right': "[AST_Node] right-hand side expression"
    },
    '_walk': def(visitor):
        node = this
        return visitor._visit(node, def():
            node.left._walk(visitor)
            node.right._walk(visitor)
        )
})

AST_Conditional = DEFNODE("Conditional", "condition consequent alternative", {
    '$documentation': "Conditional expression using the ternary operator, i.e. `a ? b : c`",
    '$propdoc': {
        'condition': "[AST_Node]",
        'consequent': "[AST_Node]",
        'alternative': "[AST_Node]"
    },
    '_walk': def(visitor):
        node = this
        return visitor._visit(node, def():
            node.condition._walk(visitor)
            node.consequent._walk(visitor)
            node.alternative._walk(visitor)
        )
})

AST_Assign = DEFNODE("Assign", None, {
    '$documentation': "An assignment expression — `a = b + 5`",

    'is_chained': def():
        return isinstance(this.right, AST_Assign) or (
            isinstance(this.right, AST_Seq) and (
                isinstance(this.right.car, AST_Assign) or isinstance(this.right.cdr, AST_Assign))
        )
    ,

    'traverse_chain': def():
        right = this.right
        while True:
            if isinstance(right, AST_Assign):
                right = right.right
                continue
            if isinstance(right, AST_Seq):
                if isinstance(right.car, AST_Assign):
                    right = new AST_Seq({'car':right.car.right, 'cdr': right.cdr})
                    continue
                if isinstance(right.cdr, AST_Assign):
                    right = right.cdr.right
                    continue
            break
        left_hand_sides = v'[this.left]'
        next = this.right
        while True:
            if isinstance(next, AST_Assign):
                left_hand_sides.push(next.left)
                next = next.right
                continue
            if isinstance(next, AST_Seq):
                if isinstance(next.cdr, AST_Assign):
                    assign = next.cdr
                    left_hand_sides.push(new AST_Seq({'car':next.car, 'cdr':assign.left}))
                    next = assign.right
                    continue
            break
        return left_hand_sides, right


}, AST_Binary)

# -----[ LITERALS ]-----
AST_Array = DEFNODE("Array", "elements", {
    '$documentation': "An array literal",
    '$propdoc': {
        'elements': "[AST_Node*] array of elements"
    },
    '_walk': def(visitor):
        node = this
        return visitor._visit(node, def():
            node.elements.forEach(def(el):
                el._walk(visitor)
            )
        )
    ,
    'flatten': def():
        def flatten(arr):
            ans = []
            for value in arr:
                if isinstance(value, AST_Seq):
                    value = value.to_array()
                elif isinstance(value, AST_Array):
                    value = value.elements
                if Array.isArray(value):
                    ans = ans.concat(flatten(value))
                else:
                    ans.push(value)
            return ans
        return flatten(this.elements)
    ,
})

AST_Object = DEFNODE("Object", "properties is_pydict", {
    '$documentation': "An object literal",
    '$propdoc': {
        'properties': "[AST_ObjectProperty*] array of properties",
        'is_pydict': "[bool] True if this object is a python dict literal"
    },
    '_walk': def(visitor):
        node = this
        return visitor._visit(node, def():
            node.properties.forEach(def(prop):
                prop._walk(visitor)
            )
        )
})

AST_ExpressiveObject = DEFNODE('ExpressiveObject', None, {
    '$documentation': 'An object literal with expressions for some keys'
}, AST_Object)

AST_ObjectProperty = DEFNODE("ObjectProperty", "key value quoted", {
    '$documentation': "Base class for literal object properties",
    '$propdoc': {
        'key': "[AST_Node] the property expression",
        'value': "[AST_Node] property value.  For setters and getters this is an AST_Function.",
    },
    '_walk': def(visitor):
        node = this
        return visitor._visit(node, def():
            node.key._walk(visitor)
            node.value._walk(visitor)
        )
})

AST_ObjectKeyVal = DEFNODE("ObjectKeyVal", None, {
    '$documentation': "A key: value object property"
}, AST_ObjectProperty)

AST_Set = DEFNODE("Set", "items", {
    '$documentation': "A set literal",
    '$propdoc': {
        'items': "[AST_SetItem*] array of items"
    },
    '_walk': def(visitor):
        node = this
        return visitor._visit(node, def():
            node.items.forEach(def(prop):
                prop._walk(visitor)
            )
        )
})

AST_SetItem = DEFNODE("SetItem", "value", {
    '$documentation': "An item in a set literal",
    '$propdoc': {
        'value': "[AST_Node] The value of this item",
    },
    '_walk': def(visitor):
        node = this
        return visitor._visit(node, def():
            node.value._walk(visitor)
        )
})

AST_Symbol = DEFNODE("Symbol", "scope name thedef", {
    '$propdoc': {
        'name': "[string] name of this symbol",
        'scope': "[AST_Scope/S] the current scope (not necessarily the definition scope)",
        'thedef': "[SymbolDef/S] the definition of this symbol"
    },
    '$documentation': "Base class for all symbols"
})

AST_SymbolAlias = DEFNODE("SymbolAlias", None, {
    '$documentation': "An alias used in an import statement or with statement"
}, AST_Symbol)

AST_SymbolDeclaration = DEFNODE("SymbolDeclaration", "init", {
    '$documentation': "A declaration symbol (symbol in var/const, function name or argument, symbol in catch)",
    '$propdoc': {
        'init': "[AST_Node*/S] array of initializers for this declaration."
    }
}, AST_Symbol)

AST_SymbolVar = DEFNODE("SymbolVar", None, {
    '$documentation': "Symbol defining a variable"
}, AST_SymbolDeclaration)

AST_ImportedVar = DEFNODE("ImportedVar", 'alias', {
    '$documentation': "Symbol defining an imported symbol",
    '$propdoc': {
        'alias': "AST_SymbolAlias the alias for this imported symbol"
    }
}, AST_SymbolVar)

AST_SymbolConst = DEFNODE("SymbolConst", None, {
    '$documentation': "A constant declaration"
}, AST_SymbolDeclaration)

AST_SymbolNonlocal = DEFNODE("SymbolNonlocal", None, {
    '$documentation': "A nonlocal declaration"
}, AST_SymbolDeclaration)

AST_SymbolFunarg = DEFNODE("SymbolFunarg", None, {
    '$documentation': "Symbol naming a function argument"
}, AST_SymbolVar)

AST_SymbolDefun = DEFNODE("SymbolDefun", None, {
    '$documentation': "Symbol defining a function"
}, AST_SymbolDeclaration)

AST_SymbolLambda = DEFNODE("SymbolLambda", None, {
    '$documentation': "Symbol naming a function expression"
}, AST_SymbolDeclaration)

AST_SymbolCatch = DEFNODE("SymbolCatch", None, {
    '$documentation': "Symbol naming the exception in catch"
}, AST_SymbolDeclaration)

AST_SymbolRef = DEFNODE("SymbolRef", "parens", {
    '$documentation': "Reference to some symbol (not definition/declaration)",
    '$propdoc': {
        'parens': "[boolean/S] if true, this variable is wrapped in parentheses"
    }
}, AST_Symbol)

AST_This = DEFNODE("This", None, {
    '$documentation': "The `this` symbol"
}, AST_Symbol)

AST_Constant = DEFNODE("Constant", None, {
    '$documentation': "Base class for all constants",
    'getValue': def():
        return this.value
})

AST_String = DEFNODE("String", "value", {
    '$documentation': "A string literal",
    '$propdoc': {
        'value': "[string] the contents of this string"
    }
}, AST_Constant)

AST_Verbatim = DEFNODE("Verbatim", "value", {
    '$documentation': "Raw JavaScript code",
    '$propdoc': {
        'value': "[string] A string of raw JS code"
    }
}, AST_Constant)

AST_Number = DEFNODE("Number", "value", {
    '$documentation': "A number literal",
    '$propdoc': {
        'value': "[number] the numeric value"
    }
}, AST_Constant)

AST_RegExp = DEFNODE("RegExp", "value", {
    '$documentation': "A regexp literal",
    '$propdoc': {
        'value': "[RegExp] the actual regexp"
    }
}, AST_Constant)

AST_Atom = DEFNODE("Atom", None, {
    '$documentation': "Base class for atoms"
}, AST_Constant)

AST_Null = DEFNODE("Null", None, {
    '$documentation': "The `null` atom",
    'value': None
}, AST_Atom)

AST_NaN = DEFNODE("NaN", None, {
    '$documentation': "The impossible value",
    'value': 0 / 0
}, AST_Atom)

AST_Undefined = DEFNODE("Undefined", None, {
    '$documentation': "The `undefined` value",
    'value': def(): pass
    .call(this)
}, AST_Atom)

AST_Hole = DEFNODE("Hole", None, {
    '$documentation': "A hole in an array",
    'value': def(): pass
    .call(this)
}, AST_Atom)

AST_Infinity = DEFNODE("Infinity", None, {
    '$documentation': "The `Infinity` value",
    'value': 1 / 0
}, AST_Atom)

AST_Boolean = DEFNODE("Boolean", None, {
    '$documentation': "Base class for booleans"
}, AST_Atom)

AST_False = DEFNODE("False", None, {
    '$documentation': "The `false` atom",
    'value': False
}, AST_Boolean)

AST_True = DEFNODE("True", None, {
    '$documentation': "The `true` atom",
    'value': True
}, AST_Boolean)

# -----[ TreeWalker ]-----
def TreeWalker(callback):
    this.visit = callback
    this.stack = []

TreeWalker.prototype = {
    '_visit': def(node, descend):
        this.stack.push(node)
        ret = this.visit(node, (descend ? def(): descend.call(node); : noop))
        if not ret and descend:
            descend.call(node)

        this.stack.pop()
        return ret
    ,
    'parent': def(n):
        return this.stack[this.stack.length - 2 - (n or 0)]
    ,
    'push': def(node):
        this.stack.push(node)
    ,
    'pop': def():
        return this.stack.pop()
    ,
    'self': def():
        return this.stack[this.stack.length - 1]
    ,
    'find_parent': def(type):
        stack = this.stack
        for i in range(stack.length-1, -1, -1):
            x = stack[i]
            if isinstance(x, type):
                return x
    ,
    'in_boolean_context': def():
        stack = this.stack
        i = stack.length
        self = stack[i -= 1]
        while i > 0:
            p = stack[i -= 1]
            if isinstance(p, AST_If) and p.condition is self
            or isinstance(p, AST_Conditional) and p.condition is self
            or isinstance(p, AST_DWLoop) and p.condition is self
            or isinstance(p, AST_UnaryPrefix) and p.operator is "!" and p.expression is self:
                return True
            if not (isinstance(p, AST_Binary) and (p.operator is "&&" or p.operator is "||")):
                return False
            self = p
}
