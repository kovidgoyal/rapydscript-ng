# vim:fileencoding=utf-8
# License: BSD

# globals: exports, console, _$rapyd$_iterator_symbol, _$rapyd$_kwargs_symbol

def abs():
    return Math.abs

def max():
    return Math.max

def min():
    return Math.min

def _$rapyd$_bind(fn, thisArg):
    if fn.orig: fn = fn.orig
    if thisArg == False: return fn
    ret = def():
        return fn.apply(thisArg, arguments)
    ret.orig = fn
    return ret

def _$rapyd$_rebind_all(thisArg, rebind):
    if JS('typeof rebind') == "undefined": rebind = True
    for JS('var p in thisArg'):
        if thisArg[p] and thisArg[p].orig:
            if rebind: thisArg[p] = _$rapyd$_bind(thisArg[p], thisArg)  # noqa:undef
            else: thisArg[p] = thisArg[p].orig  # noqa:undef

def _$rapyd$_flatten(arr):
    ans = []
    for JS('var i=0; i<arr.length; i++'):
        value = arr[i]  # noqa:undef
        if Array.isArray(value):
            ans = ans.concat(_$rapyd$_flatten(value))
        else:
            ans.push(value)
    return ans

def dir(item):
    # TODO: this isn't really representative of real Python's dir(), nor is it
    # an intuitive replacement for "for ... in" loop, need to update this logic
    # and introduce a different way of achieving "for ... in"
    arr = []
    for JS('var i in item'): arr.push(i)  # noqa:undef
    return arr

def _$rapyd$_eslice(arr, step, start, end):
    arr = arr[:]
    if type(arr) == 'string' or isinstance(arr, String):
        isString = True
        arr = arr.split('')

    if step < 0:
        step = -step
        arr.reverse()
        if type(start) != "undefined": start = arr.length - start - 1
        if type(end) != "undefined": end = arr.length - end - 1
    if type(start) == "undefined": start = 0
    if type(end) == "undefined": end = arr.length

    arr = arr.slice(start, end).filter(def(e, i): return i % step == 0;)
    return isString ? arr.join('') : arr

def _$rapyd$_extends(child, parent):
    child.prototype = Object.create(parent.prototype)
    child.prototype.constructor = child

def _$rapyd$_in():
    if type(Map) == 'function' and type(Set) == 'function':
        return def(val, arr):
            if Array.isArray(arr) or JS('typeof arr') == 'string':
                return arr.indexOf(val) != -1
            if isinstance(arr, (Map, Set)):
                return arr.has(val)
            return arr.hasOwnProperty(val)
    return def(val, arr):
            if Array.isArray(arr) or JS('typeof arr') == 'string':
                return arr.indexOf(val) != -1
            return arr.hasOwnProperty(val)

def _$rapyd$_Iterable(iterable):
    # Once ES6 is mature, change AST_ForIn to use the iterator protocol and get
    # rid of this function entirely
    if Array.isArray(iterable) or JS('typeof iterable') == 'string': return iterable
    if type(iterable[_$rapyd$_iterator_symbol]) == 'function':
        iterator = (type(Map) == 'function' and isinstance(iterable, Map)) ? iterable.keys() : iterable[_$rapyd$_iterator_symbol]()
        ans = []
        result = iterator.next()
        while not result.done:
            ans.push(result.value)
            result = iterator.next()
        return ans
    # so we can use 'for ... in' syntax with hashes and NodeLists
    return Object.keys(iterable)

def enumerate(iterable):
    if Array.isArray(iterable) or type(iterable) == 'string':
        ans = {
            '_i': -1,
            'next':def():
                this._i += 1
                if this._i < iterable.length:
                    return {'done':False, 'value':[this._i, iterable[this._i]]}
                return {'done':True}
        }
        ans[_$rapyd$_iterator_symbol] = def():
            return this
        return ans
    if type(iterable[_$rapyd$_iterator_symbol]) == 'function':
        iterator = (type(Map) == 'function' and isinstance(iterable, Map)) ? iterable.keys() : iterable[_$rapyd$_iterator_symbol]()
        ans = {
            '_iterator':iterator,
            '_i': -1,
            'next':def():
                r = this._iterator.next()
                if r.done:
                    return {'done':True}
                this._i += 1
                return {'done':False, 'value':[this._i, r.value]}
        }
        ans[_$rapyd$_iterator_symbol] = def():
            return this
        return ans
    return enumerate(Object.keys(iterable))

def reversed(iterable):
    if Array.isArray(iterable) or type(iterable) == 'string':
        ans = {
            '_i': iterable.length,
            'next':def():
                this._i -= 1
                if this._i > -1:
                    return {'done':False, 'value':iterable[this._i]}
                return {'done':True}
        }
        ans[_$rapyd$_iterator_symbol] = def():
            return this
        return ans
    raise TypeError('reversed() can only be called on arrays or strings')

def iter(iterable):
    # Generate a JavaScript iterator object from iterable
    if Array.isArray(iterable) or type(iterable) == 'string':
        ans = {
            '_i': -1,
            'next':def():
                this._i += 1
                if this._i < iterable.length:
                    return {'done':False, 'value':iterable[this._i]}
                return {'done':True}
        }
        ans[_$rapyd$_iterator_symbol] = def():
            return this
        return ans
    if type(iterable[_$rapyd$_iterator_symbol]) == 'function':
        return (type(Map) == 'function' and isinstance(iterable, Map)) ? iterable.keys() : iterable[_$rapyd$_iterator_symbol]()
    return iter(Object.keys(iterable))

def list(iterable):
    if Array.isArray(iterable):
        return iterable.slice()
    if type(iterable) == 'string':
        return iterable.split('')
    if type(iterable[_$rapyd$_iterator_symbol]) == 'function':
        iterator = (type(Map) == 'function' and isinstance(iterable, Map)) ? iterable.keys() : iterable[_$rapyd$_iterator_symbol]()
        ans = []
        result = iterator.next()
        while not result.done:
            ans.push(result.value)
            result = iterator.next()
        return ans
    return Object.keys(iterable)

def _$rapyd$_len():
    if JS('typeof Set') == 'function' and JS('typeof Map') == 'function':
        # ES 6 collections are probably present
        return (def(obj):
            if Array.isArray(obj) or JS('typeof obj') == 'string': return obj.length
            if JS('obj instanceof Set') or JS('obj instanceof Map'): return obj.size
            return Object.keys(obj).length
        )
    return (def(obj):
        if Array.isArray(obj) or JS('typeof obj') == 'string': return obj.length
        return Object.keys(obj).length
    )

def _$rapyd$_mixin(target, source, overwrite):
    for JS('var i in source'):
        if source.hasOwnProperty(i) and overwrite or JS('typeof target[i]') == 'undefined':  # noqa:undef
            target[i] = source[i]  # noqa:undef

def _$rapyd$_print():
    if JS('typeof console') == 'object':
        console.log.apply(console, arguments)

def range(start, stop, step):
    if arguments.length <= 1:
        stop = start or 0
        start = 0
    step = arguments[2] or 1
    length = Math.max(Math.ceil((stop - start) / step), 0)
    return {
        _$rapyd$_iterator_symbol: def(): return this;,
        '_i': start - step,
        '_idx': -1,
        'next': def():
            this._i += step
            this._idx += 1
            if this._idx >= length:
                return {'done':True}
            return {'done':False, 'value':this._i}
        ,
    }

def sum(arr, start):
    return arr.reduce(
        def(prev, cur): return prev+cur
        ,
        start or 0
    )

def getattr(obj, name, defval):
    try:
        ret = obj[name]
    except TypeError:
        if defval == undefined:
            raise AttributeError('The attribute ' + name + ' is not present')
        return defval
    if ret == undefined and not JS('(name in obj)'):
        if defval == undefined:
            raise AttributeError('The attribute ' + name + ' is not present')
        ret = defval
    return ret

def setattr(obj, name, value):
    obj[name] = value

def hasattr(obj, name):
    return JS('name in obj')

def _$rapyd$_desugar_kwargs():
    if type(Object.assign) == 'function':
        return def():
            ans = {}
            ans[_$rapyd$_kwargs_symbol] = True
            return Object.assign.apply(ans, arguments)
    return def():
        ans = {}
        ans[_$rapyd$_kwargs_symbol] = True
        for JS('var i = 0; i < arguments.length; i++'):
            keys = Object.keys(arguments[i])
            for JS('var j = 0; j < keys.length; j++'):
                ans[keys[j]] = arguments[i][keys[j]]  # noqa:undef
        return ans

if type(exports) == 'object':
    exports['abs()'] = abs
    exports['max()'] = max
    exports['min()'] = min
    exports.bind = _$rapyd$_bind
    exports.rebind_all = _$rapyd$_rebind_all
    exports.dir = dir
    exports.enumerate = enumerate
    exports.iter = iter
    exports.eslice = _$rapyd$_eslice
    exports.list = list
    exports.extends = _$rapyd$_extends
    exports['_$rapyd$_flatten'] = _$rapyd$_flatten
    exports['_$rapyd$_in()'] = _$rapyd$_in
    exports.iterable = _$rapyd$_Iterable
    exports['len()'] = _$rapyd$_len
    exports.mixin = _$rapyd$_mixin
    exports.print = _$rapyd$_print
    exports.range = range
    exports.reversed = reversed
    exports.sum = sum
    exports.getattr = getattr
    exports.setattr = setattr
    exports.hasattr = hasattr
    exports['_$rapyd$_desugar_kwargs()'] = _$rapyd$_desugar_kwargs
