# vim:fileencoding=utf-8
# License: BSD

# globals: exports, console, _$rapyd$_iterator_symbol, _$rapyd$_kwargs_symbol, _$rapyd$_arraylike, _$rapyd$_list_contains, _$rapyd$_list_constructor

def _$rapyd$_flatten(arr):
    ans = []
    for v'var i=0; i<arr.length; i++':
        value = arr[i]  # noqa:undef
        if Array.isArray(value):
            ans = ans.concat(_$rapyd$_flatten(value))
        else:
            ans.push(value)
    return ans

def _$rapyd$_extends(child, parent):
    child.prototype = Object.create(parent.prototype)
    child.prototype.constructor = child

_$rapyd$_in = (def ():
    if type(Map) is 'function' and type(Set) is 'function':
        return def(val, arr):
            if type(arr) is 'string':
                return arr.indexOf(val) is not -1
            if type(arr.__contains__) is 'function':
                return arr.__contains__(val)
            if isinstance(arr, (Map, Set)):
                return arr.has(val)
            if _$rapyd$_arraylike(arr):
                return _$rapyd$_list_contains.call(arr, val)
            return Object.prototype.hasOwnProperty.call(arr, val)
    return def(val, arr):
        if type(arr) is 'string':
            return arr.indexOf(val) is not -1
        if type(arr.__contains__) is 'function':
            return arr.__contains__(val)
        if _$rapyd$_arraylike(arr):
            return _$rapyd$_list_contains.call(arr, val)
        return Object.prototype.hasOwnProperty.call(arr, val)
)()

def _$rapyd$_Iterable(iterable):
    # Once ES6 is mature, change AST_ForIn to use the iterator protocol and get
    # rid of this function entirely
    if _$rapyd$_arraylike(iterable):
        return iterable
    if type(iterable[_$rapyd$_iterator_symbol]) is 'function':
        iterator = (type(Map) is 'function' and isinstance(iterable, Map)) ? iterable.keys() : iterable[_$rapyd$_iterator_symbol]()
        ans = []
        result = iterator.next()
        while not result.done:
            ans.push(result.value)
            result = iterator.next()
        return ans
    # so we can use 'for ... in' syntax with objects, as we would with dicts in python
    return Object.keys(iterable)

_$rapyd$_desugar_kwargs = (def ():
    if type(Object.assign) is 'function':
        return def():
            ans = {}
            ans[_$rapyd$_kwargs_symbol] = True
            for v'var i = 0; i < arguments.length; i++':
                Object.assign(ans, arguments[i])
            return ans
    return def():
        ans = {}
        ans[_$rapyd$_kwargs_symbol] = True
        for v'var i = 0; i < arguments.length; i++':
            keys = Object.keys(arguments[i])
            for v'var j = 0; j < keys.length; j++':
                ans[keys[j]] = arguments[i][keys[j]]
        return ans
)()

def _$rapyd$_interpolate_kwargs(f, supplied_args):
    if not f.__argnames__:
        return f.apply(this, supplied_args)
    has_prop = Object.prototype.hasOwnProperty
    kwobj = supplied_args.pop()
    if f.__handles_kwarg_interpolation__:
        args = Array(Math.max(supplied_args.length, f.__argnames__.length) + 1)
        args[-1] = kwobj
        for v'var i = 0; i < args.length - 1; i++':
            if i < f.__argnames__.length:
                prop = f.__argnames__[i]
                if has_prop.call(kwobj, prop):
                    args[i] = kwobj[prop]
                    v'delete kwobj[prop]'
                elif i < supplied_args.length:
                    args[i] = supplied_args[i]
            else:
                args[i] = supplied_args[i]
        return f.apply(this, args)

    for v'var i = 0; i < f.__argnames__.length; i++':
        prop = f.__argnames__[i]
        if has_prop.call(kwobj, prop):
            supplied_args[i] = kwobj[prop]
    return f.apply(this, supplied_args)

def _$rapyd$_interpolate_kwargs_constructor(apply, f, supplied_args):
    if apply:
        f.apply(this, supplied_args)
    else:
        _$rapyd$_interpolate_kwargs.call(this, f, supplied_args)
    return this

def _$rapyd$_getitem(obj, key):
    return obj.__getitem__(key) if obj.__getitem__ else obj[key]

def _$rapyd$_setitem(obj, key, val):
    if obj.__setitem__:
        obj.__setitem__(key, val)
    else:
        obj[key] = val

def _$rapyd$_mixin():
    # Implement a depth-first left-to-right method resolution order This is not
    # the same as python's MRO, but I really dont feel like implementing the C3
    # linearization right now, if that is even possible with prototypical
    # inheritance.
    seen = Object.create(None)
    # Ensure the following special properties are never copied
    seen.__argnames__ = seen.__handles_kwarg_interpolation__ = seen.__init__ = seen.__annotations__ = seen.__doc__ = seen.__bind_methods__ = seen.__bases__ = seen.constructor = seen.__class__ = True
    resolved_props = {}
    p = target = arguments[0].prototype
    while p and p is not Object.prototype:
        props = Object.getOwnPropertyNames(p)
        for v'var i = 0; i < props.length; i++':
            seen[props[i]] = True
        p = Object.getPrototypeOf(p)
    for v'var c = 1; c < arguments.length; c++':
        p = arguments[c].prototype
        while p and p is not Object.prototype:
            props = Object.getOwnPropertyNames(p)
            for v'var i = 0; i < props.length; i++':
                name = props[i]
                if seen[name]:
                    continue
                seen[name] = True
                resolved_props[name] = Object.getOwnPropertyDescriptor(p, name)
            p = Object.getPrototypeOf(p)
    Object.defineProperties(target, resolved_props)

def _$rapyd$_instanceof():
    obj = arguments[0]
    try:
        bases = obj.constructor.prototype.__bases__ or ''
    except Exception:
        bases = ''
    for v'var i = 1; i < arguments.length; i++':
        q = arguments[i]
        if v'obj instanceof q':
            return True
        if (q is Array or q is _$rapyd$_list_constructor) and Array.isArray(obj):
            return True
        if bases.length > 1:
            for v'var c = 1; c < bases.length; c++':
                cls = bases[c]
                while cls:
                    if q is cls:
                        return True
                    p = Object.getPrototypeOf(cls.prototype)
                    if not p:
                        break
                    cls = p.constructor
    return False
